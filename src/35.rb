## ニューラルネットワーク ##

# ここからの章は Python の Keras ライブラリを活用するスタイルになっているせいか、さすがに他言語で実装せよとは言われていないのだけど、どうせならここも Ruby で実装したかった。

# しかし方法がさっぱりわからなかった。なので Python の Keras を Ruby から使う方法でやってみたが自分にはハードルが高すぎた。

# 具体的なところで言うと Keras の fit_generator にどのようにメソッドを渡せばよいのかわからなかった。本来は Python のジェネレータ関数を渡すべきなのだけど、それに相当すると思われる Ruby の Enumerator インスタンスを渡しても動くわけがない。結局 Python のコードを芋蔓式に PyCall.exec することになってほとんど Ruby で書く意味がなくなってしまった。

# それでも35章だけは Ruby で書けた。これは Pyhton のコードを Ruby から呼ぶ方法を練習しただけであって、元のアルゴリズムを理解できているわけではない。

### 35. 浅いDense層のプログラム - ニューラルネットワーク ###

#+BEGIN_SRC
require "pycall/import"
include PyCall::Import

pyimport "keras"
pyfrom "keras.models", import: "Sequential"
pyfrom "keras.layers", import: "Dense"

require "numpy"

printable = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"\#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ \t\n\r\v\f"
Characters = printable.chars                     # => ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "!", "\"", "#", "$", "%", "&", "'", "(", ")", "*", "+", ",", "-", ".", "/", ":", ";", "<", "=", ">", "?", "@", "[", "\\", "]", "^", "_", "`", "{", "|", "}", "~", " ", "\t", "\n", "\r", "\v", "\f"]
CharIndices = Characters.collect.with_index.to_h # => {"0"=>0, "1"=>1, "2"=>2, "3"=>3, "4"=>4, "5"=>5, "6"=>6, "7"=>7, "8"=>8, "9"=>9, "a"=>10, "b"=>11, "c"=>12, "d"=>13, "e"=>14, "f"=>15, "g"=>16, "h"=>17, "i"=>18, "j"=>19, "k"=>20, "l"=>21, "m"=>22, "n"=>23, "o"=>24, "p"=>25, "q"=>26, "r"=>27, "s"=>28, "t"=>29, "u"=>30, "v"=>31, "w"=>32, "x"=>33, "y"=>34, "z"=>35, "A"=>36, "B"=>37, "C"=>38, "D"=>39, "E"=>40, "F"=>41, "G"=>42, "H"=>43, "I"=>44, "J"=>45, "K"=>46, "L"=>47, "M"=>48, "N"=>49, "O"=>50, "P"=>51, "Q"=>52, "R"=>53, "S"=>54, "T"=>55, "U"=>56, "V"=>57, "W"=>58, "X"=>59, "Y"=>60, "Z"=>61, "!"=>62, "\""=>63, "#"=>64, "$"=>65, "%"=>66, "&"=>67, "'"=>68, "("=>69, ")"=>70, "*"=>71, "+"=>72, ","=>73, "-"=>74, "."=>75, "/"=>76, ":"=>77, ";"=>78, "<"=>79, "="=>80, ">"=>81, "?"=>82, "@"=>83, "["=>84, "\\"=>85, "]"=>86, "^"=>87, "_"=>88, "`"=>89, "{"=>90, "|"=>91, "}"=>92, "~"=>93, " "=>94, "\t"=>95, "\n"=>96, "\r"=>97, "\v"=>98, "\f"=>99}
IndicesChar = CharIndices.invert                 # => {0=>"0", 1=>"1", 2=>"2", 3=>"3", 4=>"4", 5=>"5", 6=>"6", 7=>"7", 8=>"8", 9=>"9", 10=>"a", 11=>"b", 12=>"c", 13=>"d", 14=>"e", 15=>"f", 16=>"g", 17=>"h", 18=>"i", 19=>"j", 20=>"k", 21=>"l", 22=>"m", 23=>"n", 24=>"o", 25=>"p", 26=>"q", 27=>"r", 28=>"s", 29=>"t", 30=>"u", 31=>"v", 32=>"w", 33=>"x", 34=>"y", 35=>"z", 36=>"A", 37=>"B", 38=>"C", 39=>"D", 40=>"E", 41=>"F", 42=>"G", 43=>"H", 44=>"I", 45=>"J", 46=>"K", 47=>"L", 48=>"M", 49=>"N", 50=>"O", 51=>"P", 52=>"Q", 53=>"R", 54=>"S", 55=>"T", 56=>"U", 57=>"V", 58=>"W", 59=>"X", 60=>"Y", 61=>"Z", 62=>"!", 63=>"\"", 64=>"#", 65=>"$", 66=>"%", 67=>"&", 68=>"'", 69=>"(", 70=>")", 71=>"*", 72=>"+", 73=>",", 74=>"-", 75=>".", 76=>"/", 77=>":", 78=>";", 79=>"<", 80=>"=", 81=>">", 82=>"?", 83=>"@", 84=>"[", 85=>"\\", 86=>"]", 87=>"^", 88=>"_", 89=>"`", 90=>"{", 91=>"|", 92=>"}", 93=>"~", 94=>" ", 95=>"\t", 96=>"\n", 97=>"\r", 98=>"\v", 99=>"\f"}

INPUT_VOCAB_SIZE = Characters.length # => 100

def encode_one_hot(line)
  x = Numpy.zeros([line.length, INPUT_VOCAB_SIZE])
  line.chars.each.with_index do |c, i|
    if Characters.include?(c)
      index = CharIndices[c]
    else
      index = CharIndices[" "]
    end
    x[i][index] = 1
  end
  x
end

def decode_one_hot(x)
  s = []

  x.class.name         # => "Numpy::NDArray", "Numpy::NDArray", "Numpy::NDArray"
  x.size               # => 1300, 3300, 3200
  PyCall.len(x)        # => 13, 33, 32
  x.each rescue $!     # => #<NoMethodError:"undefined method `each' for array([[0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       ...,\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107]], dtype=float32):Numpy::NDArray">, #<NoMethodError:"undefined method `each' for array([[0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       ...,\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107]], dtype=float32):Numpy::NDArray">, #<NoMethodError:"undefined method `each' for array([[0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       ...,\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107]], dtype=float32):Numpy::NDArray">
  x.length rescue $!   # => #<NoMethodError:"undefined method `length' for array([[0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       ...,\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107]], dtype=float32):Numpy::NDArray">, #<NoMethodError:"undefined method `length' for array([[0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       ...,\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107]], dtype=float32):Numpy::NDArray">, #<NoMethodError:"undefined method `length' for array([[0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       ...,\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107],\n       [0.00983107, 0.00983107, 0.00983107, ..., 0.00983107, 0.00983107,\n        0.00983107]], dtype=float32):Numpy::NDArray">

  PyCall.len(x).times do |i|    # x.each は使えない
    onehot = x[i]
    one_index = Numpy.argmax(onehot)
    one_index = one_index.to_i  # one_index は Object 型になっているため to_i が必要
    s << IndicesChar[one_index]
  end
  s.join
end

def normalization_layer_set_weights(n_layer)
  wb = []

  w = Numpy.zeros([INPUT_VOCAB_SIZE, INPUT_VOCAB_SIZE], dtype: Numpy.float32)
  b = Numpy.zeros(INPUT_VOCAB_SIZE, dtype: Numpy.float32)

  ("a".."z").each do |c|
    i = CharIndices[c]
    w[i, i] = 1
  end

  ("A".."Z").each do |c|
    i = CharIndices[c]
    il = CharIndices[c.downcase]
    w[i, il] = 1
  end

  sp_idx = CharIndices[" "]
  chars = Characters - [*"a".."z"] - [*"A".."Z"]
  chars.each do |c|
    i = CharIndices[c]
    w[i, sp_idx] = 1
  end

  wb << w
  wb << b
  n_layer.set_weights(wb)
  n_layer
end

def build_model
  model = Sequential.new
  dense_layer = Dense.new(INPUT_VOCAB_SIZE, input_shape: [INPUT_VOCAB_SIZE], activation: "softmax")
  model.add(dense_layer)
  model
end

model = build_model
model.summary
normalization_layer_set_weights(model.layers[0])

# 動作検証
batch = encode_one_hot("Hello, world!")
preds = model.predict(batch)
normal = decode_one_hot(preds)          # => "hello  world "

IO.foreach("input.txt") do |line|
  line = line.strip
  if line == ""
    next
  end
  batch = encode_one_hot(line)
  preds = model.predict(batch)
  normal = decode_one_hot(preds)
  puts " in: #{line.inspect}"
  puts "out: #{normal.inspect}"
end

#+END_SRC
# >> Model: "sequential"
# >> _________________________________________________________________
# >>  Layer (type)                Output Shape              Param #
# >> =================================================================
# >>  dense (Dense)               (None, 100)               10100
# >>
# >> =================================================================
# >> Total params: 10100 (39.45 KB)
# >> Trainable params: 10100 (39.45 KB)
# >> Non-trainable params: 0 (0.00 Byte)
# >> _________________________________________________________________
# >>  in: "White tigers live mostly in India"
# >> out: "white tigers live mostly in india"
# >>  in: "Wild lions live mostly in Africa"
# >> out: "wild lions live mostly in africa"
